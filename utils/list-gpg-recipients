#!/usr/bin/env python
"""
Display recipients of gpg encrypted files.

Note: if you don't trust a key well enough to encrypt with it (without
      prompting) a warning will be displayed.
"""

try:
    from sh import gpg, ErrorReturnCode_2
except ImportError:
    raise SystemExit("please run 'pip install --user sh'")
import argparse
import os
import re
import sys

grab_id = re.compile(r'''^(gpg):.*ID\s+(?P<gpg_id>\w+)?''')

get_key_ids = gpg.bake('--no-default-keyring', '--secret-keyring', '/dev/null',
                       '--list-only', _iter='err')


def get_key_user(key):
    result = gpg('--list-key', key)
    line = result.stdout.split('\n')[1]
    if not line.startswith('uid'):
        raise IndexError(line)
    who = line.split(None,1)[1]
    return who


def check_key_validity(key):
    """ see if key is valid by trying to encrypt with it

    Note that this could also be done by parsing the output of
        gpg --list-keys --with-colons
    """
    try:
        result = gpg(
                    '--batch',
                    '--encrypt',
                    '--dry-run',
                    '--output', '/dev/null',
                    '--recipient', key,
                    '/dev/null',
        )
        valid = True
        user = None
    except ErrorReturnCode_2:
        valid = False
        user = get_key_user(key)
    return valid, user


def update_keys_needed(file_list):
    keys = set()
    for f in file_list:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                keys.add("0x{0}".format(this_id))
    # the next operation hits the keyserver
    gpg('--recv-keys', *list(keys))
    for key in keys:
        valid, who = check_key_validity(key)
        if not valid:
            sys.stderr.write("WARNING: key %s is not valid\n" % who)


def check_files(file_list):
    all_good = True
    for f in file_list:
        if not os.path.isfile(f):
            all_good = False
            sys.stderr.write("No such file '%s'\n" % (f,))
    if not all_good:
        raise SystemExit("Invalid arguments")


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--only', dest='user',
                        help='only display files USER can decrypt',
                        metavar='USER')
    parser.add_argument('-r', action='store_true', default=False,
                        dest="ids_only",
                        help='format for use as recipients for encryption')
    parser.add_argument('files', metavar='FILE', nargs='+',
                        help='a GPG/PGP encrypted file')
    args = parser.parse_args()
    check_files(args.files)
    keys = set()
    if not args.ids_only:
        update_keys_needed(args.files)
    for f in args.files:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                if args.ids_only:
                    keys.add("-r 0x{0}".format(this_id))
            elif not args.ids_only:
                this_user = "{1} 0x{0}".format(this_id, l.strip())
                if args.user:
                    if args.user in this_user:
                        keys.add(f)
                        break
                else:
                    keys.add(this_user)
    values = list(keys)
    values.sort()
    if args.ids_only:
        join = ' '
    else:
        join = '\n'
    if values:
        text = join.join(values)
        print text

if __name__ == '__main__':
    main()
