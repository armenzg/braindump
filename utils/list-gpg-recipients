#!/usr/bin/env python
"""
Display recipients of gpg encrypted files.

Note: if you don't trust a key well enough to encrypt with it (without
      prompting) a warning will be displayed.
"""

try:
    from sh import gpg, ErrorReturnCode_2
except ImportError:
    raise SystemExit("please run 'pip install --user sh'")
import argparse
import os
import re
import sys
import json

grab_id = re.compile(r'''^(gpg):.*ID\s+(0x)?(?P<gpg_id>\w+)?''')
# tweaking regex's is hard -- we expect the above to match both:
test_matches = [
    "gpg: encrypted with 2048-bit ELG key, ID FFFFFFFF, created",
    "gpg: encrypted with 2048-bit RSA key, ID 0xFFFFFFFFFFFFFFFF, created",
]
# testing every time is easy:
for s in test_matches:
    assert(grab_id.match(s).groupdict()['gpg_id'].startswith('FFFFFFFF'))

get_key_ids = gpg.bake('--no-default-keyring', '--secret-keyring', '/dev/null',
                       '--list-only', _iter='err')


def get_key_user(key):
    result = gpg('--list-key', key)
    line = result.stdout.split('\n')[1]
    if not line.startswith('uid'):
        raise IndexError(line)
    who = line.split(None, 1)[1]
    return who


def check_key_validity(key):
    """ see if key is valid by trying to encrypt with it

    Note that this could also be done by parsing the output of
        gpg --list-keys --with-colons
    """
    try:
        gpg(
            '--batch',
            '--encrypt',
            '--dry-run',
            '--output', '/dev/null',
            '--recipient', key,
            '/dev/null',
        )
        valid = True
        user = None
    except ErrorReturnCode_2:
        valid = False
        user = get_key_user(key)
    return valid, user


def update_keys_needed(file_list):
    keys = set()
    for f in file_list:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                keys.add("0x{0}".format(this_id))
    try:
        # the next operation hits the keyserver
        gpg('--recv-keys', *list(keys))
        for key in keys:
            valid, who = check_key_validity(key)
            if not valid:
                sys.stderr.write("WARNING: you don't consider key %s valid\n" %
                                 who)
    except ErrorReturnCode_2 as e:
        # TODO: would be nicer to allow listing, but not encryption, if keys
        # can't be validated.
        raise SystemExit("Can't get one or more keys from server:\n%s" %
                         e.stderr)


def check_files(file_list):
    all_good = True
    for f in file_list:
        if not os.path.isfile(f):
            all_good = False
            sys.stderr.write("No such file '%s'\n" % (f,))
    if not all_good:
        raise SystemExit("Invalid arguments")


def read_exclude_file(file_name):
    '''Extract the key IDs to exclude, if file exists'''
    ids = set()
    try:
        data = json.load(open(file_name, 'r'))
        ids = [x['id'] for x in data]
    except:
        # ignore this for now, probably should scream if user specified file
        # name, and we did not find that
        raise SystemExit("Can't open alumni file '%s'" % file_name)
    return ids


def is_id_excluded(key_id, excluded_ids):
    if key_id in excluded_ids:
        return True

    for x in excluded_ids:
        if key_id.endswith(x):
            return True
    return False


def output_keys(keys, args):
    values = list(keys)
    values.sort()
    if args.ids_only or args.email_only:
        join = ' '
    else:
        join = '\n'
    if values:
        text = join.join(values)
        print text


def parse_args():
    # get the directory of the script, to use as default of directory of alumni
    # file
    alumni_file = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                               './alumni.json')
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--only', dest='user',
                        help='only display files USER can decrypt',
                        metavar='USER')
    parser.add_argument('-r', action='store_true', default=False,
                        dest="ids_only",
                        help='format for use as recipients for encryption')
    parser.add_argument('-m', action='store_true', default=False,
                        dest="email_only",
                        help='format for use as recipients for email')
    # you can "defeat" the default alumni file in two ways:
    #   - specify /dev/null as the file
    #   - explicitly add the person as a recipient when encrypting
    parser.add_argument('--alumni', metavar='ALUMS', default=alumni_file,
                        help="a json file of ID's no longer in group")
    parser.add_argument('files', metavar='FILE', nargs='+',
                        help='a GPG/PGP encrypted file')
    return parser.parse_args()


def main():
    args = parse_args()
    check_files(args.files)
    exclude_ids = read_exclude_file(args.alumni)
    keys = set()
    if not args.ids_only:
        update_keys_needed(args.files)
    for f in args.files:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                if args.ids_only and not is_id_excluded(this_id, exclude_ids):
                    keys.add("-r 0x{0}".format(this_id))
            elif not args.ids_only:
                add_user = True
                if args.email_only:
                    this_user = "{0}".format(l.strip())
                    this_user = this_user[
                        this_user.find('<'):this_user.rfind('>') + 1]
                    if this_user[0] == this_user[-1]:
                        # strip quotes
                        this_user = this_user[1:-1]
                    add_alumni = False
                else:
                    this_user = "{1} 0x{0}".format(this_id, l.strip())
                    add_alumni = True
                if args.user:
                    if args.user in this_user:
                        keys.add(f)
                        break  # from all id's for this file
                else:
                    if is_id_excluded(this_id, exclude_ids):
                        this_user = "ALUMNI: %s" % this_user
                        add_user = add_alumni
                    if add_user:
                        keys.add(this_user)
    output_keys(keys, args)

if __name__ == '__main__':
    main()
