#!/usr/bin/env python
"""
Display recipients of gpg encrypted files.

Note: if you don't trust a key well enough to encrypt with it (without
      prompting) a warning will be displayed.
"""

try:
    from sh import gpg, ErrorReturnCode_2
except ImportError:
    raise SystemExit("please run 'pip install --user sh'")
import argparse
import os
import re
import sys
import json

grab_id = re.compile(r'''^(gpg):.*ID\s+(?P<gpg_id>\w+)?''')

get_key_ids = gpg.bake('--no-default-keyring', '--secret-keyring', '/dev/null',
                       '--list-only', _iter='err')


def get_key_user(key):
    result = gpg('--list-key', key)
    line = result.stdout.split('\n')[1]
    if not line.startswith('uid'):
        raise IndexError(line)
    who = line.split(None,1)[1]
    return who


def check_key_validity(key):
    """ see if key is valid by trying to encrypt with it

    Note that this could also be done by parsing the output of
        gpg --list-keys --with-colons
    """
    try:
        result = gpg(
                    '--batch',
                    '--encrypt',
                    '--dry-run',
                    '--output', '/dev/null',
                    '--recipient', key,
                    '/dev/null',
        )
        valid = True
        user = None
    except ErrorReturnCode_2:
        valid = False
        user = get_key_user(key)
    return valid, user


def update_keys_needed(file_list):
    keys = set()
    for f in file_list:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                keys.add("0x{0}".format(this_id))
    # the next operation hits the keyserver
    gpg('--recv-keys', *list(keys))
    for key in keys:
        valid, who = check_key_validity(key)
        if not valid:
            sys.stderr.write("WARNING: you don't consider key %s valid\n" %
                             who)


def check_files(file_list):
    all_good = True
    for f in file_list:
        if not os.path.isfile(f):
            all_good = False
            sys.stderr.write("No such file '%s'\n" % (f,))
    if not all_good:
        raise SystemExit("Invalid arguments")


def read_exclude_file(file_name):
    '''Extract the key IDs to exclude, if file exists'''
    ids = set()
    try:
        data = json.load(open(file_name, 'r'))
        ids = [x['id'] for x in data]
    except:
        # ignore this for now, probably should scream if user specified file
        # name, and we did not find that
        pass
    return ids


def main():
    # get the directory of the script, to use as default of directory of alumni
    # file
    alumni_file = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                               './alumni.json')
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--only', dest='user',
                        help='only display files USER can decrypt',
                        metavar='USER')
    parser.add_argument('-r', action='store_true', default=False,
                        dest="ids_only",
                        help='format for use as recipients for encryption')
    # you can "defeat" the default alumni file in two ways:
    #   - specify /dev/null as the file
    #   - explicitly add the person as a recipient when encrypting
    parser.add_argument('--alumni', metavar='ALUMS', default=alumni_file,
                        help="a json file of ID's no longer in group")
    parser.add_argument('files', metavar='FILE', nargs='+',
                        help='a GPG/PGP encrypted file')
    args = parser.parse_args()
    check_files(args.files)
    exclude_ids = read_exclude_file(args.alumni)
    keys = set()
    if not args.ids_only:
        update_keys_needed(args.files)
    for f in args.files:
        for l in get_key_ids(f):
            gpg_id = grab_id.match(l)
            if gpg_id:
                this_id = gpg_id.groupdict()['gpg_id']
                if args.ids_only and this_id not in exclude_ids:
                    keys.add("-r 0x{0}".format(this_id))
            elif not args.ids_only:
                this_user = "{1} 0x{0}".format(this_id, l.strip())
                if args.user:
                    if args.user in this_user:
                        keys.add(f)
                        break
                else:
                    if this_id in exclude_ids:
                        this_user = "ALUMNI: %s" % this_user
                    keys.add(this_user)
    values = list(keys)
    values.sort()
    if args.ids_only:
        join = ' '
    else:
        join = '\n'
    if values:
        text = join.join(values)
        print text

if __name__ == '__main__':
    main()
